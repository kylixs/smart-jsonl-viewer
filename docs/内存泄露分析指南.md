# 内存泄露分析指南

## 1. 生成带 Sourcemap 的构建

### 方法一：使用 dev 构建脚本（推荐）

```bash
npm run build:dev
```

这会生成带 sourcemap 的开发构建，文件输出到 `dist/` 目录。

### 方法二：临时修改配置

编辑 `vite.config.ts`，临时启用 sourcemap：

```typescript
build: {
  sourcemap: true,  // 临时改为 true
  // ...
}
```

然后运行：
```bash
npm run build
```

## 2. 加载扩展到 Chrome

1. 打开 Chrome 浏览器
2. 访问 `chrome://extensions/`
3. 开启"开发者模式"
4. 点击"加载已解压的扩展程序"
5. 选择项目的 `dist` 目录

## 3. 使用 Chrome DevTools 分析内存泄露

### 3.1 打开 DevTools

- **方式 1**：打开扩展页面（viewer）
  - 右键点击扩展图标 → "审查弹出内容"
  - 或访问显示 JSONL 文件的页面，按 F12

- **方式 2**：分析后台脚本
  - 访问 `chrome://extensions/`
  - 找到你的扩展，点击"审查视图：background.html"

### 3.2 Memory 面板使用

#### 步骤 1：记录初始堆快照

1. 打开 DevTools → Memory 面板
2. 选择 "Heap snapshot"
3. 点击 "Take snapshot"
4. 命名为 "Baseline"

#### 步骤 2：执行操作

执行可能导致内存泄露的操作，例如：
- 打开/关闭字符串解码窗口多次
- 切换不同的 JSONL 文件
- 搜索/过滤大量数据
- 切换主题
- 切换语言

#### 步骤 3：记录操作后的堆快照

1. 执行完操作后，再次点击 "Take snapshot"
2. 命名为 "After Action"

#### 步骤 4：比较快照

1. 在 Memory 面板中选择 "After Action" 快照
2. 切换视图模式为 "Comparison"（对比）
3. 选择对比的基线快照（Baseline）
4. 查看：
   - **# New**：新增的对象数量
   - **# Deleted**：删除的对象数量
   - **# Delta**：净增加的对象数量
   - **Alloc. Size**：分配的内存大小
   - **Freed Size**：释放的内存大小
   - **Size Delta**：净增加的内存大小

### 3.3 识别内存泄露

#### 典型泄露特征：

1. **对象数量持续增长**
   - 执行操作后，某些对象数量显著增加且不会减少

2. **闭包泄露**
   - 查找 `(closure)` 对象，检查是否持有大量数据

3. **事件监听器未清理**
   - 搜索 `EventListener`
   - 检查是否有大量未移除的监听器

4. **定时器未清理**
   - 搜索 `Timer` 或 `setInterval`

5. **DOM 节点泄露**
   - 搜索 `Detached HTMLElement`
   - 这些是已从 DOM 树移除但仍在内存中的节点

### 3.4 定位泄露源代码

1. **查看 Retainers（保持者）**
   - 点击泄露的对象
   - 查看下方的 "Retainers" 面板
   - 追踪引用链，找到是谁持有这个对象

2. **使用 Sourcemap 定位**
   - 在 Retainers 中，双击函数名
   - DevTools 会通过 sourcemap 跳转到原始源代码位置

## 4. Performance 面板分析

### 4.1 记录性能分析

1. 打开 DevTools → Performance 面板
2. 勾选 "Memory" 选项
3. 点击 "Record" 开始录制
4. 执行操作（如多次打开/关闭解码窗口）
5. 点击 "Stop" 停止录制

### 4.2 分析内存走势

- **JS Heap**：查看 JavaScript 堆内存走势
  - 如果呈现锯齿状（上升-下降）：正常，说明垃圾回收在工作
  - 如果持续上升不下降：可能存在内存泄露

- **Nodes**：DOM 节点数量
  - 节点数量应该在操作完成后回到基线
  - 如果持续增长：可能存在 DOM 泄露

- **Event Listeners**：事件监听器数量
  - 数量应该保持稳定或在合理范围内
  - 如果持续增长：可能未正确移除监听器

## 5. 常见内存泄露场景和修复

### 5.1 Vue 组件中的定时器

❌ **错误示例**：
```typescript
export default {
  mounted() {
    this.timer = setInterval(() => {
      // 某些操作
    }, 1000)
  }
  // 忘记清理 timer
}
```

✅ **正确示例**：
```typescript
export default {
  mounted() {
    this.timer = setInterval(() => {
      // 某些操作
    }, 1000)
  },
  beforeUnmount() {
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
  }
}
```

### 5.2 全局事件监听器

❌ **错误示例**：
```typescript
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize)
  }
  // 忘记移除监听器
}
```

✅ **正确示例**：
```typescript
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize)
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize)
  }
}
```

### 5.3 大对象缓存

❌ **错误示例**：
```typescript
const cache = new Map()

function processData(data) {
  cache.set(data.id, data) // 永久缓存，不清理
}
```

✅ **正确示例**：
```typescript
const cache = new Map()
const MAX_CACHE_SIZE = 100

function processData(data) {
  cache.set(data.id, data)

  // 限制缓存大小
  if (cache.size > MAX_CACHE_SIZE) {
    const firstKey = cache.keys().next().value
    cache.delete(firstKey)
  }
}

// 或使用 WeakMap（如果键是对象）
const cache = new WeakMap()
```

### 5.4 闭包持有大对象

❌ **错误示例**：
```typescript
function createHandler(largeData) {
  return function() {
    // 闭包持有 largeData
    console.log(largeData.length)
  }
}
```

✅ **正确示例**：
```typescript
function createHandler(largeData) {
  const length = largeData.length // 只保留需要的部分
  return function() {
    console.log(length)
  }
}
```

### 5.5 DOM 引用

❌ **错误示例**：
```typescript
export default {
  data() {
    return {
      myElement: null
    }
  },
  mounted() {
    this.myElement = document.querySelector('.my-element')
  }
  // 组件销毁后，仍持有 DOM 引用
}
```

✅ **正确示例**：
```typescript
export default {
  data() {
    return {
      myElement: null
    }
  },
  mounted() {
    this.myElement = document.querySelector('.my-element')
  },
  beforeUnmount() {
    this.myElement = null
  }
}
```

## 6. 自动化检测工具

### 6.1 Chrome DevTools Protocol

可以编写脚本自动检测内存泄露：

```javascript
// 使用 Puppeteer
const puppeteer = require('puppeteer');

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // 获取初始内存
  const metrics1 = await page.metrics();
  console.log('Initial JSHeapUsedSize:', metrics1.JSHeapUsedSize);

  // 执行操作
  await page.evaluate(() => {
    // 模拟用户操作
  });

  // 强制垃圾回收（需要启动时添加 --expose-gc 参数）
  await page.evaluate(() => {
    if (window.gc) window.gc();
  });

  // 获取操作后内存
  const metrics2 = await page.metrics();
  console.log('After JSHeapUsedSize:', metrics2.JSHeapUsedSize);
  console.log('Delta:', metrics2.JSHeapUsedSize - metrics1.JSHeapUsedSize);

  await browser.close();
})();
```

### 6.2 Leak Canary（概念）

在代码中添加检测点：

```typescript
// 在开发环境检测内存泄露
if (import.meta.env.DEV) {
  let objectCount = 0

  const originalPush = Array.prototype.push
  Array.prototype.push = function(...items) {
    objectCount += items.length
    if (objectCount > 10000) {
      console.warn('可能存在内存泄露：数组元素过多', objectCount)
    }
    return originalPush.apply(this, items)
  }
}
```

## 7. 项目特定的检查点

### 7.1 StringDecoder 组件

检查点：
- [ ] 打开/关闭解码窗口 10 次，内存是否回到基线？
- [ ] 切换语言时，是否正确卸载 Shiki 高亮器？
- [ ] 大量代码高亮后，内存是否合理？

### 7.2 JSONL 渲染

检查点：
- [ ] 滚动加载大文件，内存是否线性增长？
- [ ] 是否实现了虚拟滚动？
- [ ] 离开页面后，数据是否被清理？

### 7.3 搜索过滤

检查点：
- [ ] 多次搜索后，旧的搜索结果是否被清理？
- [ ] 搜索高亮是否正确移除？

### 7.4 主题切换

检查点：
- [ ] 切换主题时，旧的样式表是否被移除？
- [ ] Shiki 主题是否正确切换？

## 8. 最佳实践

1. **定期进行内存分析**
   - 在每次重大功能更新后进行内存测试

2. **使用 WeakMap/WeakSet**
   - 对于临时关联的对象，使用 WeakMap/WeakSet

3. **限制缓存大小**
   - 所有缓存都应该有上限

4. **使用 unref**
   - Vue 3 中，使用 `unref()` 或 `toRaw()` 避免持有响应式对象

5. **及时清理**
   - 在组件的 `beforeUnmount` 中清理所有资源
   - 定时器、事件监听器、订阅、WebSocket 等

6. **避免全局变量**
   - 减少全局作用域中的大对象

7. **使用 Chrome Memory Monitor**
   - Chrome DevTools → More Tools → Memory Monitor
   - 实时监控内存使用情况

## 9. 快速检测命令

在浏览器控制台执行：

```javascript
// 1. 获取当前内存使用
console.log('Memory:', performance.memory)

// 2. 强制垃圾回收（Chrome 启动时需加 --js-flags="--expose-gc"）
if (window.gc) {
  window.gc()
  console.log('GC executed')
}

// 3. 查看 Vue 组件实例数量
const app = document.querySelector('#app').__VUE_APP__
console.log('Vue instances:', app)

// 4. 检查事件监听器
const listeners = getEventListeners(window)
console.log('Window listeners:', listeners)
```

## 10. 参考资源

- [Chrome DevTools Memory Profiling](https://developer.chrome.com/docs/devtools/memory-problems/)
- [Vue.js Memory Leaks Prevention](https://vuejs.org/guide/best-practices/performance.html)
- [JavaScript Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
