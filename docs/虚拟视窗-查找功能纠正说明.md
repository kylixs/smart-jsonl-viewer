# 虚拟视窗数据流与查找功能纠正说明

## ❌ 错误理解

之前的设计中，我把查找放在了数据流转的核心路径：

```
原始数据 (allLines)
    ↓ 过滤 filter
过滤结果 (filteredLines)
    ↓ 查找 find  ← ❌ 错误：查找不应该在主流程中
查找匹配 (findMatches[])
    ↓ 视窗 viewport
可见数据 (visibleItems)
```

这是**错误的**，因为查找不应该改变数据流。

---

## ✅ 正确理解

查找是**附加功能**，与主数据流完全独立：

```
┌─────────────────────────────────────────┐
│         主数据流（核心流程）              │
│                                         │
│  原始数据 (allLines)                     │
│      ↓ 过滤 filter                      │
│  过滤结果 (filteredLines)                │
│      ↓ 虚拟视窗 viewport                 │
│  可见数据 (visibleItems: 30-40行)        │
│      ↓ 渲染 render                      │
│  DOM 节点 (30-40个)                      │
│                                         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│       查找功能（附加功能，独立）           │
│                                         │
│  查找输入 (keyword)                      │
│      ↓ 遍历 filteredLines               │
│  查找结果 (findMatches[]: 索引数组)      │
│      ↓ 影响                             │
│  1. 改变视窗位置（滚动到匹配项）          │
│  2. 添加高亮样式（CSS class）            │
│                                         │
│  注意：不改变数据，不影响虚拟滚动计算     │
└─────────────────────────────────────────┘
```

---

## 核心区别

### 过滤（Filter）
- **改变数据**: `allLines` → `filteredLines`
- **影响范围**:
  - 总数量变化
  - 虚拟滚动总高度重新计算
  - 视窗范围重新计算
  - 重置到第一行

### 查找（Find）
- **不改变数据**: `filteredLines` 保持不变
- **影响范围**:
  - **仅改变视窗位置**（滚动到匹配项）
  - **仅添加高亮样式**（CSS）
  - 不影响总数量
  - 不影响虚拟滚动计算

---

## 正确的实现方式

### 1. 查找引擎（独立模块）

```typescript
/**
 * 查找引擎（附加功能，不影响数据流）
 */
class FindEngine {
  private findMatches: number[] = []      // 匹配项的索引数组
  private currentMatchIndex: number = -1  // 当前查看的匹配项位置

  /**
   * 执行查找
   * 注意：不改变 filteredLines，只生成索引数组
   */
  find(
    filteredLines: JsonLineNode[],  // 只读，不修改
    keyword: string
  ): number[] {
    // 清空旧结果
    this.findMatches = []
    this.currentMatchIndex = -1

    // 遍历生成索引数组
    filteredLines.forEach((line, index) => {
      if (this.matchLine(line, keyword)) {
        this.findMatches.push(index)  // 只记录索引
      }
    })

    // 如果有结果，定位到第一个
    if (this.findMatches.length > 0) {
      this.currentMatchIndex = 0
    }

    return this.findMatches
  }

  /**
   * 下一个匹配
   * 只改变 currentMatchIndex，触发视窗位置变化
   */
  findNext(): number | null {
    if (this.findMatches.length === 0) {
      return null
    }

    this.currentMatchIndex = (this.currentMatchIndex + 1) % this.findMatches.length

    // 返回要滚动到的索引
    return this.findMatches[this.currentMatchIndex]
  }

  /**
   * 上一个匹配
   */
  findPrevious(): number | null {
    if (this.findMatches.length === 0) {
      return null
    }

    this.currentMatchIndex = this.currentMatchIndex - 1
    if (this.currentMatchIndex < 0) {
      this.currentMatchIndex = this.findMatches.length - 1
    }

    return this.findMatches[this.currentMatchIndex]
  }

  /**
   * 判断某行是否为匹配项（用于添加高亮样式）
   */
  isMatch(index: number): boolean {
    return this.findMatches.includes(index)
  }

  /**
   * 判断某行是否为当前匹配项（用于添加当前高亮样式）
   */
  isCurrentMatch(index: number): boolean {
    if (this.currentMatchIndex < 0) {
      return false
    }
    return this.findMatches[this.currentMatchIndex] === index
  }

  /**
   * 获取查找状态
   */
  getStatus() {
    return {
      total: this.findMatches.length,
      current: this.currentMatchIndex >= 0 ? this.currentMatchIndex + 1 : 0
    }
  }

  /**
   * 清空查找
   */
  clear(): void {
    this.findMatches = []
    this.currentMatchIndex = -1
  }

  private matchLine(line: JsonLineNode, keyword: string): boolean {
    return line.rawContent.toLowerCase().includes(keyword.toLowerCase())
  }
}
```

### 2. 虚拟滚动控制器（主流程）

```typescript
/**
 * 虚拟滚动控制器（主流程）
 */
class VirtualScrollController {
  private scrollEngine: VirtualScrollEngine
  private filterEngine: FilterEngine
  private findEngine: FindEngine  // 独立的查找引擎

  // 数据层（主流程）
  private allLines: JsonLineNode[] = []
  private filteredLines: JsonLineNode[] = []

  /**
   * 应用过滤（主流程）
   */
  async applyFilter(keyword: string): Promise<void> {
    // 1. 执行过滤（改变数据）
    this.filteredLines = this.filterEngine.filter(this.allLines, keyword)

    // 2. 更新虚拟滚动（重新计算）
    this.scrollEngine.setTotalCount(this.filteredLines.length)
    this.scrollEngine.scrollToIndex(0)  // 重置到第一行

    // 3. 清空查找结果（因为数据变了）
    this.findEngine.clear()

    console.log('[过滤] 完成:', {
      原始: this.allLines.length,
      过滤后: this.filteredLines.length
    })
  }

  /**
   * 执行查找（附加功能）
   */
  async performFind(keyword: string): Promise<void> {
    // 执行查找（不改变数据，只生成索引）
    const matches = this.findEngine.find(this.filteredLines, keyword)

    // 如果有结果，滚动到第一个匹配项
    if (matches.length > 0) {
      const firstMatchIndex = matches[0]

      // 只改变视窗位置
      this.scrollEngine.scrollToIndex(firstMatchIndex, {
        align: 'center',
        smooth: true,
        highlight: true
      })
    }

    console.log('[查找] 完成:', {
      匹配数: matches.length,
      数据总数: this.filteredLines.length  // 数据没变
    })
  }

  /**
   * 查找下一个
   */
  findNext(): void {
    const nextIndex = this.findEngine.findNext()

    if (nextIndex !== null) {
      // 只改变视窗位置
      this.scrollEngine.scrollToIndex(nextIndex, {
        align: 'center',
        smooth: true,
        highlight: true
      })
    }
  }

  /**
   * 获取可见数据（用于渲染）
   */
  getVisibleData(): JsonLineNode[] {
    const range = this.scrollEngine.getRenderRange()
    return this.filteredLines.slice(range.start, range.end)
  }

  /**
   * 判断某行是否需要高亮（查找匹配）
   */
  isFindMatch(index: number): boolean {
    return this.findEngine.isMatch(index)
  }

  /**
   * 判断某行是否为当前查找项
   */
  isCurrentFindMatch(index: number): boolean {
    return this.findEngine.isCurrentMatch(index)
  }
}
```

### 3. Vue 组件渲染

```vue
<template>
  <div class="virtual-viewport">
    <!-- 过滤面板（影响数据） -->
    <div class="filter-panel">
      <input
        v-model="filterKeyword"
        placeholder="过滤数据..."
        @input="handleFilter"
      />
      <span>{{ filteredCount }} / {{ totalCount }} 行</span>
    </div>

    <!-- 查找面板（不影响数据，只改变视窗） -->
    <FindPanel
      :visible="findVisible"
      @find="handleFind"
      @find-next="handleFindNext"
      @close="closeFindPanel"
    />

    <!-- 虚拟滚动列表 -->
    <div class="scroll-container" @scroll="handleScroll">
      <div class="virtual-spacer" :style="spacerStyle"></div>

      <div class="content-wrapper" :style="contentStyle">
        <div
          v-for="item in visibleItems"
          :key="item.id"
          class="virtual-item"
          :class="{
            'find-match': isFindMatch(item.index),
            'find-current': isCurrentFindMatch(item.index)
          }"
        >
          {{ item.content }}
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// 过滤（影响数据）
async function handleFilter() {
  await controller.applyFilter(filterKeyword.value)

  // 更新统计
  totalCount.value = controller.allLines.length
  filteredCount.value = controller.filteredLines.length  // 数据变了

  // 更新可见数据
  visibleItems.value = controller.getVisibleData()
}

// 查找（不影响数据，只改变视窗）
async function handleFind(keyword: string) {
  await controller.performFind(keyword)

  // 注意：filteredCount 不变，数据没变
  // 只是滚动到了匹配项

  // 更新可见数据（因为视窗位置变了）
  visibleItems.value = controller.getVisibleData()
}

// 查找下一个
function handleFindNext() {
  controller.findNext()

  // 更新可见数据（视窗位置变了）
  visibleItems.value = controller.getVisibleData()
}

// 滚动时更新可见数据
function handleScroll() {
  visibleItems.value = controller.getVisibleData()
}
</script>

<style scoped>
/* 查找匹配项高亮（通过 CSS class） */
.virtual-item.find-match {
  background: #fff3cd;
  border-left: 3px solid #ffc107;
}

.virtual-item.find-current {
  background: #ffeb3b;
  border-left: 3px solid #ff9800;
  animation: pulse 0.5s;
}
</style>
```

---

## 关键要点总结

### 1. 数据流独立

| 功能 | 是否改变数据 | 影响 |
|------|-------------|------|
| **过滤** | ✅ 是 | allLines → filteredLines<br>总数变化<br>虚拟滚动重新计算<br>重置到第一行 |
| **查找** | ❌ 否 | 不改变 filteredLines<br>只生成索引数组<br>只改变视窗位置<br>只添加高亮样式 |

### 2. 查找的职责

查找引擎只做两件事：
1. **生成索引数组**: `findMatches = [3, 15, 28, 45, ...]`
2. **提供判断方法**: `isMatch(index)`, `isCurrentMatch(index)`

查找**不负责**：
- ❌ 修改数据
- ❌ 计算虚拟滚动
- ❌ 直接操作 DOM

### 3. 视窗位置控制

查找只是**触发**滚动，由虚拟滚动引擎执行：

```typescript
// 查找引擎返回索引
const matchIndex = findEngine.findNext()

// 虚拟滚动引擎负责滚动
scrollEngine.scrollToIndex(matchIndex)

// 虚拟滚动引擎负责计算可见范围
const visibleItems = getVisibleData()
```

### 4. 高亮显示

高亮只是**CSS 类名**，不影响数据：

```vue
<div
  :class="{
    'find-match': findEngine.isMatch(index),      // 普通匹配
    'find-current': findEngine.isCurrentMatch(index)  // 当前匹配
  }"
>
```

---

## 总结

**过滤 vs 查找**：

```
过滤（Filter）:
  输入: allLines + keyword
  输出: filteredLines（新数据）
  影响: 数据、总数、虚拟滚动计算

查找（Find）:
  输入: filteredLines（只读） + keyword
  输出: findMatches[]（索引数组）
  影响: 视窗位置、高亮样式
  不影响: 数据、总数、虚拟滚动计算
```

查找是**纯粹的附加功能**，就像给文本添加荧光笔标记一样，不改变文本内容本身。

感谢你的纠正！这个理解非常重要，避免了架构设计上的错误。
