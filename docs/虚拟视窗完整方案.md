# è™šæ‹Ÿè§†çª—å®Œæ•´æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•

1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
3. [æ•°æ®åŠ è½½](#æ•°æ®åŠ è½½)
4. [æ»šåŠ¨ç³»ç»Ÿ](#æ»šåŠ¨ç³»ç»Ÿ)
5. [é”®ç›˜å¯¼èˆª](#é”®ç›˜å¯¼èˆª)
6. [è¿‡æ»¤åŠŸèƒ½](#è¿‡æ»¤åŠŸèƒ½)
7. [æŸ¥æ‰¾å®šä½](#æŸ¥æ‰¾å®šä½)
8. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
9. [å®Œæ•´å®ç°](#å®Œæ•´å®ç°)

---

## æ¶æ„æ¦‚è§ˆ

### ç³»ç»Ÿåˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç”¨æˆ·äº¤äº’å±‚ (UI Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ æ»šåŠ¨æ§åˆ¶  â”‚ é”®ç›˜å¯¼èˆª  â”‚ æŸ¥æ‰¾é¢æ¿  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       æ•°æ®ç®¡ç†å±‚ (Data Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ åŸå§‹æ•°æ®  â”‚ è¿‡æ»¤æ•°æ®  â”‚ æŸ¥æ‰¾ç´¢å¼•  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æ¸²æŸ“å¼•æ“ (Render Engine)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ è§†çª—è®¡ç®—  â”‚ DOMæ¸²æŸ“   â”‚ é«˜äº®æ˜¾ç¤º  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæ¦‚å¿µ

```
åŸå§‹æ•°æ® (allLines)
    â†“ è¿‡æ»¤ (filter)
è¿‡æ»¤ç»“æœ (filteredLines)
    â†“ æŸ¥æ‰¾ (find)
æŸ¥æ‰¾åŒ¹é… (findMatches[])
    â†“ è§†çª— (viewport)
å¯è§æ•°æ® (visibleItems)
    â†“ æ¸²æŸ“ (render)
DOM èŠ‚ç‚¹ (30-40ä¸ª)
```

---

## æ ¸å¿ƒåŠŸèƒ½

### 1. æ•°æ®æµè½¬

```typescript
// æ•°æ®ç»“æ„å®šä¹‰
interface DataLayer {
  // åŸå§‹æ•°æ®ï¼ˆä¸å¯å˜ï¼‰
  allLines: JsonLineNode[]

  // è¿‡æ»¤åçš„æ•°æ®
  filteredLines: JsonLineNode[]

  // æŸ¥æ‰¾ç»“æœç´¢å¼•
  findMatches: number[]

  // å½“å‰æŸ¥æ‰¾ä½ç½®
  currentFindIndex: number

  // è§†çª—çŠ¶æ€
  viewport: {
    startIndex: number
    endIndex: number
    renderStartIndex: number
    renderEndIndex: number
  }
}
```

### 2. åŠŸèƒ½çŸ©é˜µ

| åŠŸèƒ½ | è¾“å…¥ | è¾“å‡º | å½±å“ |
|------|------|------|------|
| åŠ è½½ | æ–‡æœ¬å†…å®¹ | allLines | åˆå§‹åŒ–æ•°æ® |
| è¿‡æ»¤ | å…³é”®å­— | filteredLines | é‡ç½®è§†çª— |
| æŸ¥æ‰¾ | æŸ¥æ‰¾è¯ | findMatches[] | é«˜äº®åŒ¹é… |
| æ»šåŠ¨ | scrollTop | viewport | æ›´æ–°æ¸²æŸ“ |
| é”®ç›˜ | Key | å¯¼èˆªåŠ¨ä½œ | ç§»åŠ¨è§†çª— |

---

## æ•°æ®åŠ è½½

### å¢é‡è§£æç­–ç•¥

```typescript
/**
 * æ•°æ®åŠ è½½ç®¡ç†å™¨
 */
class DataLoader {
  private chunkSize = 100 // æ¯æ‰¹è§£æ 100 è¡Œ

  /**
   * å¢é‡åŠ è½½æ–‡æœ¬
   * @returns é¦–æ‰¹æ•°æ® + åå°ç»§ç»­è§£æ
   */
  async loadText(text: string): Promise<{
    initial: JsonLineNode[]  // é¦–æ‰¹ 100 è¡Œ
    total: number            // é¢„ä¼°æ€»è¡Œæ•°
    onProgress: (callback: (lines: JsonLineNode[]) => void) => void
  }> {
    const lines = text.split('\n')
    const totalLines = lines.length

    // é¦–æ‰¹ï¼šç«‹å³è§£æå‰ 100 è¡Œ
    const initialBatch = this.parseLines(lines.slice(0, this.chunkSize))

    // åå°ï¼šå¼‚æ­¥è§£æå‰©ä½™æ•°æ®
    const progressCallbacks: Array<(lines: JsonLineNode[]) => void> = []

    setTimeout(() => {
      this.parseRemaining(lines.slice(this.chunkSize), (parsed) => {
        progressCallbacks.forEach(cb => cb(parsed))
      })
    }, 0)

    return {
      initial: initialBatch,
      total: totalLines,
      onProgress: (callback) => {
        progressCallbacks.push(callback)
      }
    }
  }

  /**
   * åå°è§£æï¼ˆåˆ†æ‰¹ï¼Œé¿å…é˜»å¡ UIï¼‰
   */
  private async parseRemaining(
    lines: string[],
    onBatch: (lines: JsonLineNode[]) => void
  ) {
    const batches = Math.ceil(lines.length / this.chunkSize)

    for (let i = 0; i < batches; i++) {
      const start = i * this.chunkSize
      const end = Math.min(start + this.chunkSize, lines.length)
      const batch = lines.slice(start, end)

      // ä½¿ç”¨ requestIdleCallback é¿å…é˜»å¡
      await this.waitForIdle()

      const parsed = this.parseLines(batch)
      onBatch(parsed)
    }
  }

  /**
   * ç­‰å¾…æµè§ˆå™¨ç©ºé—²
   */
  private waitForIdle(): Promise<void> {
    return new Promise(resolve => {
      if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(() => resolve())
      } else {
        setTimeout(resolve, 0)
      }
    })
  }

  /**
   * è§£æè¡Œæ•°æ®
   */
  private parseLines(lines: string[]): JsonLineNode[] {
    return lines
      .filter(line => line.trim())
      .map((line, index) => ({
        id: `line-${Date.now()}-${index}`,
        lineNumber: index + 1,
        rawContent: line,
        parsedData: this.tryParseJSON(line),
        isExpanded: true
      }))
  }

  private tryParseJSON(line: string): any {
    try {
      return JSON.parse(line)
    } catch {
      return { _raw: line }
    }
  }
}
```

### åŠ è½½æµç¨‹

```
ç”¨æˆ·æ‰“å¼€æ–‡ä»¶
    â†“
é¢„ä¼°æ€»è¡Œæ•°ï¼ˆå¿«é€Ÿæ‰«ææ¢è¡Œç¬¦ï¼‰
    â†“
è§£æé¦–æ‰¹ 100 è¡Œï¼ˆ< 50msï¼‰
    â†“
ç«‹å³æ˜¾ç¤ºé¦–å±
    â†“
åå°ç»§ç»­è§£æå‰©ä½™æ•°æ®
    â†“
æ¯æ‰¹ 100 è¡Œï¼Œä½¿ç”¨ requestIdleCallback
    â†“
å…¨éƒ¨è§£æå®Œæˆ
```

---

## æ»šåŠ¨ç³»ç»Ÿ

### è§†çª—è®¡ç®—

```typescript
/**
 * è™šæ‹Ÿæ»šåŠ¨å¼•æ“
 */
class VirtualScrollEngine {
  private config = {
    itemHeight: 40,      // æ¯è¡Œé«˜åº¦
    viewportRows: 20,    // è§†çª—è¡Œæ•°ï¼ˆåŠ¨æ€è®¡ç®—ï¼‰
    bufferSize: 5,       // ç¼“å†²åŒºå¤§å°
    smoothScroll: true   // å¹³æ»‘æ»šåŠ¨
  }

  private state = {
    totalCount: 0,       // æ€»æ•°æ®è¡Œæ•°
    scrollTop: 0,        // æ»šåŠ¨ä½ç½®
    startIndex: 0,       // å¯è§èµ·å§‹
    endIndex: 0,         // å¯è§ç»“æŸ
    renderStartIndex: 0, // æ¸²æŸ“èµ·å§‹ï¼ˆå«ç¼“å†²ï¼‰
    renderEndIndex: 0,   // æ¸²æŸ“ç»“æŸï¼ˆå«ç¼“å†²ï¼‰
    totalHeight: 0,      // è™šæ‹Ÿæ€»é«˜åº¦
    offsetY: 0           // å†…å®¹åç§»
  }

  /**
   * å¤„ç†æ»šåŠ¨äº‹ä»¶
   */
  handleScroll(scrollTop: number) {
    // é˜²æŠ–ä¼˜åŒ–ï¼ˆ16ms = 60 FPSï¼‰
    if (this.scrollRAF) {
      cancelAnimationFrame(this.scrollRAF)
    }

    this.scrollRAF = requestAnimationFrame(() => {
      this.state.scrollTop = scrollTop
      this.updateViewport()
      this.scrollRAF = null
    })
  }

  /**
   * æ›´æ–°è§†çª—èŒƒå›´
   */
  private updateViewport() {
    const { itemHeight, viewportRows, bufferSize } = this.config
    const { scrollTop, totalCount } = this.state

    // 1. è®¡ç®—å¯è§åŒºåŸŸ
    const startIndex = Math.floor(scrollTop / itemHeight)
    const endIndex = Math.min(startIndex + viewportRows, totalCount)

    // 2. åŠ ä¸Šç¼“å†²åŒº
    const renderStartIndex = Math.max(0, startIndex - bufferSize)
    const renderEndIndex = Math.min(totalCount, endIndex + bufferSize)

    // 3. è®¡ç®—åç§»é‡
    const offsetY = renderStartIndex * itemHeight

    // 4. æ›´æ–°çŠ¶æ€
    this.state.startIndex = startIndex
    this.state.endIndex = endIndex
    this.state.renderStartIndex = renderStartIndex
    this.state.renderEndIndex = renderEndIndex
    this.state.offsetY = offsetY

    console.log('[è™šæ‹Ÿæ»šåŠ¨] è§†çª—æ›´æ–°:', {
      å¯è§: `${startIndex} - ${endIndex}`,
      æ¸²æŸ“: `${renderStartIndex} - ${renderEndIndex}`,
      åç§»: `${offsetY}px`
    })
  }

  /**
   * æ»šåŠ¨åˆ°æŒ‡å®šç´¢å¼•
   */
  scrollToIndex(index: number, options?: {
    align?: 'start' | 'center' | 'end'  // å¯¹é½æ–¹å¼
    smooth?: boolean                     // å¹³æ»‘æ»šåŠ¨
    highlight?: boolean                  // æ˜¯å¦é«˜äº®
  }) {
    const { itemHeight, viewportRows } = this.config
    const align = options?.align || 'start'

    let scrollTop: number

    switch (align) {
      case 'start':
        scrollTop = index * itemHeight
        break
      case 'center':
        scrollTop = (index - Math.floor(viewportRows / 2)) * itemHeight
        break
      case 'end':
        scrollTop = (index - viewportRows + 1) * itemHeight
        break
    }

    // è¾¹ç•Œæ£€æŸ¥
    scrollTop = Math.max(0, Math.min(scrollTop, this.state.totalHeight - viewportRows * itemHeight))

    // æ‰§è¡Œæ»šåŠ¨
    this.container?.scrollTo({
      top: scrollTop,
      behavior: options?.smooth ? 'smooth' : 'auto'
    })

    // é«˜äº®è¡Œï¼ˆå¯é€‰ï¼‰
    if (options?.highlight) {
      this.highlightRow(index)
    }
  }

  /**
   * é«˜äº®æŒ‡å®šè¡Œï¼ˆçŸ­æš‚é—ªçƒæ•ˆæœï¼‰
   */
  private highlightRow(index: number) {
    const rowElement = document.querySelector(`[data-index="${index}"]`)
    if (rowElement) {
      rowElement.classList.add('highlight-flash')
      setTimeout(() => {
        rowElement.classList.remove('highlight-flash')
      }, 1000)
    }
  }

  /**
   * è·å–å½“å‰æ¸²æŸ“èŒƒå›´
   */
  getRenderRange(): { start: number; end: number } {
    return {
      start: this.state.renderStartIndex,
      end: this.state.renderEndIndex
    }
  }

  /**
   * è·å–è™šæ‹Ÿå®¹å™¨æ ·å¼
   */
  getContainerStyle(): { height: string } {
    return {
      height: `${this.state.totalHeight}px`
    }
  }

  /**
   * è·å–å†…å®¹åŒºåŸŸæ ·å¼
   */
  getContentStyle(): { transform: string } {
    return {
      transform: `translateY(${this.state.offsetY}px)`
    }
  }
}
```

### æ»šåŠ¨ä¼˜åŒ–

```typescript
// 1. ä½¿ç”¨ transform ä»£æ›¿ top/leftï¼ˆGPU åŠ é€Ÿï¼‰
.content-wrapper {
  transform: translateY(0);
  will-change: transform;
}

// 2. ä½¿ç”¨ requestAnimationFrame é˜²æŠ–
handleScroll(scrollTop: number) {
  cancelAnimationFrame(this.rafId)
  this.rafId = requestAnimationFrame(() => {
    this.updateViewport()
  })
}

// 3. è™šæ‹ŸåŒ–å®¹å™¨ä½¿ç”¨å›ºå®šå®šä½
.virtual-spacer {
  position: absolute;
  pointer-events: none;
}
```

---

## é”®ç›˜å¯¼èˆª

### æ”¯æŒçš„æŒ‰é”®

```typescript
/**
 * é”®ç›˜å¯¼èˆªç®¡ç†å™¨
 */
class KeyboardNavigator {
  private shortcuts = {
    // è¡Œçº§å¯¼èˆª
    'ArrowUp': () => this.moveLine(-1),
    'ArrowDown': () => this.moveLine(1),

    // é¡µçº§å¯¼èˆª
    'PageUp': () => this.movePage(-1),
    'PageDown': () => this.movePage(1),

    // è¾¹ç•Œå¯¼èˆª
    'Home': () => this.moveToStart(),
    'End': () => this.moveToEnd(),

    // æŸ¥æ‰¾å¯¼èˆª
    'F3': () => this.findNext(),
    'Shift+F3': () => this.findPrevious(),
    'Ctrl+F': () => this.openFindPanel(),
    'Escape': () => this.closeFindPanel(),

    // å±•å¼€/æŠ˜å 
    'Space': () => this.toggleExpand(),

    // å¿«æ·è·³è½¬
    'Ctrl+G': () => this.openGotoLine()
  }

  /**
   * ç§»åŠ¨è¡Œ
   */
  private moveLine(delta: number) {
    const currentIndex = this.getCurrentVisibleIndex()
    const newIndex = currentIndex + delta

    if (newIndex >= 0 && newIndex < this.getTotalCount()) {
      this.scrollEngine.scrollToIndex(newIndex, {
        align: 'center',
        smooth: true,
        highlight: true
      })
    }
  }

  /**
   * ç¿»é¡µ
   */
  private movePage(direction: number) {
    const pageSize = this.scrollEngine.getViewportRows()
    const currentIndex = this.getCurrentVisibleIndex()
    const newIndex = currentIndex + (direction * pageSize)

    this.scrollEngine.scrollToIndex(newIndex, {
      align: 'start',
      smooth: true
    })
  }

  /**
   * ç§»åŠ¨åˆ°å¼€å§‹/ç»“æŸ
   */
  private moveToStart() {
    this.scrollEngine.scrollToIndex(0, {
      align: 'start',
      smooth: true
    })
  }

  private moveToEnd() {
    const lastIndex = this.getTotalCount() - 1
    this.scrollEngine.scrollToIndex(lastIndex, {
      align: 'end',
      smooth: true
    })
  }

  /**
   * è·å–å½“å‰å¯è§çš„ä¸­å¿ƒè¡Œç´¢å¼•
   */
  private getCurrentVisibleIndex(): number {
    const { startIndex, endIndex } = this.scrollEngine.getViewport()
    return Math.floor((startIndex + endIndex) / 2)
  }

  /**
   * ç»‘å®šé”®ç›˜äº‹ä»¶
   */
  bind() {
    document.addEventListener('keydown', this.handleKeyDown.bind(this))
  }

  /**
   * å¤„ç†é”®ç›˜äº‹ä»¶
   */
  private handleKeyDown(event: KeyboardEvent) {
    // æ„å»ºå¿«æ·é”®å­—ç¬¦ä¸²
    const key = [
      event.ctrlKey && 'Ctrl',
      event.shiftKey && 'Shift',
      event.altKey && 'Alt',
      event.key
    ].filter(Boolean).join('+')

    // æŸ¥æ‰¾å¹¶æ‰§è¡Œå¯¹åº”çš„æ“ä½œ
    const handler = this.shortcuts[key]
    if (handler) {
      event.preventDefault()
      handler()
    }
  }
}
```

### Page Up/Down å®ç°

```typescript
/**
 * Page Up/Down çš„ç²¾ç¡®å®ç°
 */
class PageNavigator {
  /**
   * å‘ä¸Šç¿»é¡µ
   */
  pageUp() {
    const viewport = this.scrollEngine.getViewport()
    const pageSize = viewport.endIndex - viewport.startIndex

    // æ–°çš„èµ·å§‹ä½ç½® = å½“å‰èµ·å§‹ - é¡µå¤§å°
    let newStartIndex = viewport.startIndex - pageSize

    // ä¿ç•™ 1 è¡Œé‡å ï¼ˆæ›´å¥½çš„ä¸Šä¸‹æ–‡è¿ç»­æ€§ï¼‰
    newStartIndex = Math.max(0, newStartIndex + 1)

    this.scrollEngine.scrollToIndex(newStartIndex, {
      align: 'start',
      smooth: true
    })

    console.log('[ç¿»é¡µ] Page Up:', {
      æ—§èŒƒå›´: `${viewport.startIndex} - ${viewport.endIndex}`,
      æ–°èµ·å§‹: newStartIndex
    })
  }

  /**
   * å‘ä¸‹ç¿»é¡µ
   */
  pageDown() {
    const viewport = this.scrollEngine.getViewport()
    const pageSize = viewport.endIndex - viewport.startIndex
    const totalCount = this.getTotalCount()

    // æ–°çš„èµ·å§‹ä½ç½® = å½“å‰ç»“æŸ - 1ï¼ˆé‡å è¡Œï¼‰
    let newStartIndex = viewport.endIndex - 1

    // ç¡®ä¿ä¸è¶…è¿‡æ€»æ•°
    newStartIndex = Math.min(newStartIndex, totalCount - pageSize)

    this.scrollEngine.scrollToIndex(newStartIndex, {
      align: 'start',
      smooth: true
    })

    console.log('[ç¿»é¡µ] Page Down:', {
      æ—§èŒƒå›´: `${viewport.startIndex} - ${viewport.endIndex}`,
      æ–°èµ·å§‹: newStartIndex
    })
  }
}
```

---

## è¿‡æ»¤åŠŸèƒ½

### è¿‡æ»¤å¼•æ“

```typescript
/**
 * æ•°æ®è¿‡æ»¤å¼•æ“
 */
class FilterEngine {
  private allData: JsonLineNode[] = []
  private filteredData: JsonLineNode[] = []

  /**
   * åº”ç”¨è¿‡æ»¤
   */
  applyFilter(options: {
    keyword: string
    mode: 'fuzzy' | 'exact' | 'regex' | 'jsonpath'
    caseSensitive: boolean
    jsonPath?: string
  }): FilterResult {
    const startTime = performance.now()

    // æ¸…ç©ºæ—§çš„è¿‡æ»¤ç»“æœ
    this.filteredData = []

    if (!options.keyword.trim()) {
      // æ— å…³é”®å­—ï¼Œæ˜¾ç¤ºå…¨éƒ¨
      this.filteredData = this.allData
    } else {
      // æ‰§è¡Œè¿‡æ»¤
      this.filteredData = this.filterLines(this.allData, options)
    }

    const endTime = performance.now()

    return {
      total: this.allData.length,
      matched: this.filteredData.length,
      duration: endTime - startTime
    }
  }

  /**
   * è¿‡æ»¤æ•°æ®è¡Œ
   */
  private filterLines(
    lines: JsonLineNode[],
    options: FilterOptions
  ): JsonLineNode[] {
    const { keyword, mode, caseSensitive, jsonPath } = options

    return lines.filter(line => {
      switch (mode) {
        case 'fuzzy':
          return this.fuzzyMatch(line, keyword, caseSensitive)

        case 'exact':
          return this.exactMatch(line, keyword, caseSensitive)

        case 'regex':
          return this.regexMatch(line, keyword, caseSensitive)

        case 'jsonpath':
          return this.jsonPathMatch(line, keyword, jsonPath!, caseSensitive)

        default:
          return false
      }
    })
  }

  /**
   * æ¨¡ç³ŠåŒ¹é…
   */
  private fuzzyMatch(line: JsonLineNode, keyword: string, caseSensitive: boolean): boolean {
    const content = caseSensitive ? line.rawContent : line.rawContent.toLowerCase()
    const search = caseSensitive ? keyword : keyword.toLowerCase()

    return content.includes(search)
  }

  /**
   * ç²¾ç¡®åŒ¹é…
   */
  private exactMatch(line: JsonLineNode, keyword: string, caseSensitive: boolean): boolean {
    const content = caseSensitive ? line.rawContent : line.rawContent.toLowerCase()
    const search = caseSensitive ? keyword : keyword.toLowerCase()

    return content === search
  }

  /**
   * æ­£åˆ™åŒ¹é…
   */
  private regexMatch(line: JsonLineNode, pattern: string, caseSensitive: boolean): boolean {
    try {
      const flags = caseSensitive ? 'g' : 'gi'
      const regex = new RegExp(pattern, flags)
      return regex.test(line.rawContent)
    } catch (err) {
      console.error('æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯:', err)
      return false
    }
  }

  /**
   * JSONPath åŒ¹é…
   */
  private jsonPathMatch(
    line: JsonLineNode,
    keyword: string,
    jsonPath: string,
    caseSensitive: boolean
  ): boolean {
    try {
      // ä½¿ç”¨ JSONPath æå–å€¼
      const value = this.extractByPath(line.parsedData, jsonPath)

      if (value === undefined) {
        return false
      }

      const valueStr = String(value)
      const content = caseSensitive ? valueStr : valueStr.toLowerCase()
      const search = caseSensitive ? keyword : keyword.toLowerCase()

      return content.includes(search)
    } catch (err) {
      return false
    }
  }

  /**
   * æå– JSON è·¯å¾„çš„å€¼
   */
  private extractByPath(obj: any, path: string): any {
    const parts = path.split('.')
    let current = obj

    for (const part of parts) {
      if (current && typeof current === 'object' && part in current) {
        current = current[part]
      } else {
        return undefined
      }
    }

    return current
  }

  /**
   * è·å–è¿‡æ»¤ç»“æœ
   */
  getFilteredData(): JsonLineNode[] {
    return this.filteredData
  }

  /**
   * æ¸…ç©ºè¿‡æ»¤
   */
  clearFilter() {
    this.filteredData = this.allData
  }
}
```

### è¿‡æ»¤æµç¨‹

```
ç”¨æˆ·è¾“å…¥å…³é”®å­—
    â†“
é€‰æ‹©è¿‡æ»¤æ¨¡å¼ï¼ˆfuzzy/exact/regex/jsonpathï¼‰
    â†“
éå† allDataï¼Œæ‰§è¡ŒåŒ¹é…
    â†“
ç”Ÿæˆ filteredData
    â†“
é‡ç½®è™šæ‹Ÿæ»šåŠ¨è§†çª—
    â†“
æ¸…ç©ºæŸ¥æ‰¾ç»“æœï¼ˆè¿‡æ»¤åéœ€è¦é‡æ–°æŸ¥æ‰¾ï¼‰
    â†“
æ¸²æŸ“ç¬¬ä¸€å±
```

---

## æŸ¥æ‰¾å®šä½

### æŸ¥æ‰¾å¼•æ“

```typescript
/**
 * æŸ¥æ‰¾å®šä½å¼•æ“ï¼ˆåŒºåˆ«äºè¿‡æ»¤ï¼‰
 */
class FindEngine {
  private findMatches: number[] = []      // åŒ¹é…çš„ç´¢å¼•æ•°ç»„
  private currentMatchIndex: number = -1  // å½“å‰æŸ¥æ‰¾ä½ç½®
  private findKeyword: string = ''

  /**
   * æ‰§è¡ŒæŸ¥æ‰¾
   * æ³¨æ„ï¼šæŸ¥æ‰¾æ˜¯åœ¨ filteredData ä¸Šè¿›è¡Œçš„ï¼Œä¸æ˜¯ allData
   */
  find(keyword: string, options: {
    caseSensitive: boolean
    wholeWord: boolean
    regex: boolean
  }): FindResult {
    const startTime = performance.now()

    // æ¸…ç©ºæ—§çš„æŸ¥æ‰¾ç»“æœ
    this.findMatches = []
    this.currentMatchIndex = -1
    this.findKeyword = keyword

    if (!keyword.trim()) {
      return {
        total: 0,
        current: 0,
        duration: 0
      }
    }

    // è·å–å½“å‰çš„è¿‡æ»¤ç»“æœï¼ˆæŸ¥æ‰¾åœ¨è¿‡æ»¤ç»“æœä¸­è¿›è¡Œï¼‰
    const dataToSearch = this.filterEngine.getFilteredData()

    // éå†æŸ¥æ‰¾åŒ¹é…é¡¹
    dataToSearch.forEach((line, index) => {
      if (this.matchLine(line, keyword, options)) {
        this.findMatches.push(index)
      }
    })

    // å¦‚æœæœ‰ç»“æœï¼Œå®šä½åˆ°ç¬¬ä¸€ä¸ª
    if (this.findMatches.length > 0) {
      this.currentMatchIndex = 0
      this.scrollToCurrentMatch()
    }

    const endTime = performance.now()

    return {
      total: this.findMatches.length,
      current: this.currentMatchIndex + 1,
      duration: endTime - startTime
    }
  }

  /**
   * åŒ¹é…å•è¡Œ
   */
  private matchLine(
    line: JsonLineNode,
    keyword: string,
    options: FindOptions
  ): boolean {
    let content = line.rawContent
    let search = keyword

    // å¤§å°å†™
    if (!options.caseSensitive) {
      content = content.toLowerCase()
      search = search.toLowerCase()
    }

    // æ­£åˆ™æ¨¡å¼
    if (options.regex) {
      try {
        const flags = options.caseSensitive ? 'g' : 'gi'
        const regex = new RegExp(search, flags)
        return regex.test(content)
      } catch {
        return false
      }
    }

    // å…¨å­—åŒ¹é…
    if (options.wholeWord) {
      const regex = new RegExp(`\\b${this.escapeRegex(search)}\\b`, options.caseSensitive ? '' : 'i')
      return regex.test(content)
    }

    // æ™®é€šåŒ¹é…
    return content.includes(search)
  }

  /**
   * ä¸‹ä¸€ä¸ªåŒ¹é…
   */
  findNext(): void {
    if (this.findMatches.length === 0) {
      return
    }

    this.currentMatchIndex = (this.currentMatchIndex + 1) % this.findMatches.length
    this.scrollToCurrentMatch()

    console.log('[æŸ¥æ‰¾] ä¸‹ä¸€ä¸ª:', {
      å½“å‰: this.currentMatchIndex + 1,
      æ€»æ•°: this.findMatches.length
    })
  }

  /**
   * ä¸Šä¸€ä¸ªåŒ¹é…
   */
  findPrevious(): void {
    if (this.findMatches.length === 0) {
      return
    }

    this.currentMatchIndex = this.currentMatchIndex - 1
    if (this.currentMatchIndex < 0) {
      this.currentMatchIndex = this.findMatches.length - 1
    }

    this.scrollToCurrentMatch()

    console.log('[æŸ¥æ‰¾] ä¸Šä¸€ä¸ª:', {
      å½“å‰: this.currentMatchIndex + 1,
      æ€»æ•°: this.findMatches.length
    })
  }

  /**
   * æ»šåŠ¨åˆ°å½“å‰åŒ¹é…é¡¹
   */
  private scrollToCurrentMatch(): void {
    if (this.currentMatchIndex < 0 || this.currentMatchIndex >= this.findMatches.length) {
      return
    }

    const matchIndex = this.findMatches[this.currentMatchIndex]

    // æ»šåŠ¨åˆ°åŒ¹é…é¡¹ï¼Œå¹¶å±…ä¸­æ˜¾ç¤º
    this.scrollEngine.scrollToIndex(matchIndex, {
      align: 'center',
      smooth: true,
      highlight: true
    })
  }

  /**
   * è·å–æŸ¥æ‰¾çŠ¶æ€
   */
  getFindStatus(): {
    total: number
    current: number
    keyword: string
  } {
    return {
      total: this.findMatches.length,
      current: this.currentMatchIndex >= 0 ? this.currentMatchIndex + 1 : 0,
      keyword: this.findKeyword
    }
  }

  /**
   * åˆ¤æ–­æŸè¡Œæ˜¯å¦ä¸ºå½“å‰æŸ¥æ‰¾åŒ¹é…é¡¹
   */
  isCurrentMatch(index: number): boolean {
    if (this.currentMatchIndex < 0) {
      return false
    }
    return this.findMatches[this.currentMatchIndex] === index
  }

  /**
   * åˆ¤æ–­æŸè¡Œæ˜¯å¦ä¸ºæŸ¥æ‰¾åŒ¹é…é¡¹ï¼ˆä½†ä¸æ˜¯å½“å‰é¡¹ï¼‰
   */
  isMatch(index: number): boolean {
    return this.findMatches.includes(index)
  }

  /**
   * æ¸…ç©ºæŸ¥æ‰¾
   */
  clearFind(): void {
    this.findMatches = []
    this.currentMatchIndex = -1
    this.findKeyword = ''
  }

  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  }
}
```

### æŸ¥æ‰¾ UI ç»„ä»¶

```vue
<template>
  <div class="find-panel" v-show="visible">
    <div class="find-input-group">
      <!-- æŸ¥æ‰¾è¾“å…¥æ¡† -->
      <input
        ref="findInput"
        v-model="findKeyword"
        type="text"
        placeholder="æŸ¥æ‰¾..."
        @keydown.enter="handleFindNext"
        @keydown.shift.enter="handleFindPrevious"
        @keydown.escape="closeFindPanel"
      />

      <!-- æŸ¥æ‰¾é€‰é¡¹ -->
      <div class="find-options">
        <button
          :class="{ active: caseSensitive }"
          @click="caseSensitive = !caseSensitive"
          title="åŒºåˆ†å¤§å°å†™ (Alt+C)"
        >
          Aa
        </button>
        <button
          :class="{ active: wholeWord }"
          @click="wholeWord = !wholeWord"
          title="å…¨å­—åŒ¹é… (Alt+W)"
        >
          [ab]
        </button>
        <button
          :class="{ active: useRegex }"
          @click="useRegex = !useRegex"
          title="æ­£åˆ™è¡¨è¾¾å¼ (Alt+R)"
        >
          .*
        </button>
      </div>

      <!-- æŸ¥æ‰¾ç»“æœç»Ÿè®¡ -->
      <div class="find-status">
        <span v-if="findStatus.total > 0">
          {{ findStatus.current }} / {{ findStatus.total }}
        </span>
        <span v-else-if="findKeyword && findStatus.total === 0">
          æ— ç»“æœ
        </span>
      </div>

      <!-- å¯¼èˆªæŒ‰é’® -->
      <div class="find-navigation">
        <button
          @click="handleFindPrevious"
          :disabled="findStatus.total === 0"
          title="ä¸Šä¸€ä¸ª (Shift+Enter)"
        >
          â†‘
        </button>
        <button
          @click="handleFindNext"
          :disabled="findStatus.total === 0"
          title="ä¸‹ä¸€ä¸ª (Enter)"
        >
          â†“
        </button>
      </div>

      <!-- å…³é—­æŒ‰é’® -->
      <button class="close-btn" @click="closeFindPanel" title="å…³é—­ (Escape)">
        âœ•
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, nextTick } from 'vue'

const props = defineProps<{
  visible: boolean
}>()

const emit = defineEmits<{
  'find': [keyword: string, options: FindOptions]
  'find-next': []
  'find-previous': []
  'close': []
}>()

const findInput = ref<HTMLInputElement | null>(null)
const findKeyword = ref('')
const caseSensitive = ref(false)
const wholeWord = ref(false)
const useRegex = ref(false)

const findStatus = ref({
  total: 0,
  current: 0
})

// ç›‘å¬è¾“å…¥å˜åŒ–ï¼Œå®æ—¶æŸ¥æ‰¾
watch([findKeyword, caseSensitive, wholeWord, useRegex], () => {
  performFind()
}, { immediate: false })

// é¢æ¿æ‰“å¼€æ—¶èšç„¦è¾“å…¥æ¡†
watch(() => props.visible, (visible) => {
  if (visible) {
    nextTick(() => {
      findInput.value?.focus()
      findInput.value?.select()
    })
  }
})

function performFind() {
  if (!findKeyword.value.trim()) {
    findStatus.value = { total: 0, current: 0 }
    return
  }

  emit('find', findKeyword.value, {
    caseSensitive: caseSensitive.value,
    wholeWord: wholeWord.value,
    regex: useRegex.value
  })
}

function handleFindNext() {
  emit('find-next')
}

function handleFindPrevious() {
  emit('find-previous')
}

function closeFindPanel() {
  emit('close')
}

// æš´éœ²ç»™çˆ¶ç»„ä»¶
defineExpose({
  updateStatus(status: { total: number; current: number }) {
    findStatus.value = status
  }
})
</script>

<style scoped>
.find-panel {
  position: fixed;
  top: 16px;
  right: 16px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  padding: 8px;
  z-index: 1000;
  min-width: 400px;
}

.find-input-group {
  display: flex;
  align-items: center;
  gap: 8px;
}

.find-input-group input {
  flex: 1;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

.find-options {
  display: flex;
  gap: 4px;
}

.find-options button {
  padding: 4px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;
}

.find-options button.active {
  background: #007bff;
  color: #fff;
  border-color: #007bff;
}

.find-status {
  font-size: 12px;
  color: #666;
  min-width: 60px;
  text-align: center;
}

.find-navigation {
  display: flex;
  gap: 2px;
}

.find-navigation button {
  padding: 4px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.find-navigation button:hover:not(:disabled) {
  background: #f0f0f0;
}

.find-navigation button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.close-btn {
  padding: 4px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
  font-size: 16px;
}

.close-btn:hover {
  background: #f0f0f0;
}

/* æš—è‰²ä¸»é¢˜ */
:root.dark .find-panel {
  background: #2a2a2a;
  border-color: #444;
}

:root.dark .find-input-group input {
  background: #1e1e1e;
  border-color: #555;
  color: #ddd;
}

:root.dark .find-options button,
:root.dark .find-navigation button,
:root.dark .close-btn {
  background: #333;
  border-color: #555;
  color: #ddd;
}
</style>
```

### é«˜äº®æ˜¾ç¤º

```vue
<!-- åœ¨åˆ—è¡¨é¡¹ä¸­æ ‡è®°æŸ¥æ‰¾åŒ¹é… -->
<div
  class="virtual-item"
  :class="{
    'find-match': isFindMatch(item.index),
    'find-current': isCurrentFindMatch(item.index)
  }"
>
  <!-- å†…å®¹ -->
</div>

<style>
/* æŸ¥æ‰¾åŒ¹é…é¡¹ï¼ˆéå½“å‰ï¼‰ */
.virtual-item.find-match {
  background: #fff3cd;
  border-left: 3px solid #ffc107;
}

/* å½“å‰æŸ¥æ‰¾é¡¹ï¼ˆé«˜äº®ï¼‰ */
.virtual-item.find-current {
  background: #ffeb3b;
  border-left: 3px solid #ff9800;
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.02);
  }
}

/* æš—è‰²ä¸»é¢˜ */
:root.dark .virtual-item.find-match {
  background: #3a3a00;
  border-left-color: #807300;
}

:root.dark .virtual-item.find-current {
  background: #4a4a00;
  border-left-color: #b3a100;
}
</style>
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ»šåŠ¨æ€§èƒ½

```typescript
// ä½¿ç”¨ requestAnimationFrame é˜²æŠ–
handleScroll(scrollTop: number) {
  if (this.scrollRAF) {
    cancelAnimationFrame(this.scrollRAF)
  }

  this.scrollRAF = requestAnimationFrame(() => {
    this.updateViewport()
  })
}

// ä½¿ç”¨ transform ä»£æ›¿ top
.content-wrapper {
  transform: translateY(0);
  will-change: transform;
}
```

### 2. æŸ¥æ‰¾æ€§èƒ½

```typescript
// å¤§æ•°æ®æŸ¥æ‰¾ä½¿ç”¨ Web Worker
class FindWorker {
  private worker: Worker

  constructor() {
    this.worker = new Worker('/find-worker.js')
  }

  async find(data: JsonLineNode[], keyword: string): Promise<number[]> {
    return new Promise((resolve) => {
      this.worker.postMessage({ data, keyword })
      this.worker.onmessage = (e) => {
        resolve(e.data.matches)
      }
    })
  }
}

// find-worker.js
self.onmessage = function(e) {
  const { data, keyword } = e.data
  const matches = []

  data.forEach((line, index) => {
    if (line.rawContent.includes(keyword)) {
      matches.push(index)
    }
  })

  self.postMessage({ matches })
}
```

### 3. è¿‡æ»¤æ€§èƒ½

```typescript
// ä½¿ç”¨å¢é‡è¿‡æ»¤
class IncrementalFilter {
  async filter(data: JsonLineNode[], keyword: string): Promise<JsonLineNode[]> {
    const chunkSize = 1000
    const chunks = Math.ceil(data.length / chunkSize)
    const results: JsonLineNode[] = []

    for (let i = 0; i < chunks; i++) {
      const start = i * chunkSize
      const end = Math.min(start + chunkSize, data.length)
      const chunk = data.slice(start, end)

      // æ¯æ‰¹è¿‡æ»¤åç­‰å¾…æµè§ˆå™¨ç©ºé—²
      await this.waitForIdle()

      const filtered = chunk.filter(line =>
        line.rawContent.includes(keyword)
      )

      results.push(...filtered)

      // é€šçŸ¥è¿›åº¦
      this.onProgress?.(i / chunks)
    }

    return results
  }
}
```

### 4. å†…å­˜ä¼˜åŒ–

```typescript
// é‡Šæ”¾æ—§æ•°æ®
function clearOldData() {
  // æ¸…ç©ºæ•°ç»„
  if (this.filteredLines.length > 0) {
    this.filteredLines.length = 0
    this.filteredLines = []
  }

  // æ¸…ç©ºæŸ¥æ‰¾ç»“æœ
  if (this.findMatches.length > 0) {
    this.findMatches.length = 0
    this.findMatches = []
  }

  // è§¦å‘åƒåœ¾å›æ”¶æç¤º
  if (import.meta.env.DEV) {
    console.log('[å†…å­˜] æ—§æ•°æ®å·²æ¸…ç†')
  }
}
```

---

## å®Œæ•´å®ç°

### ä¸»æ§åˆ¶å™¨

```typescript
/**
 * è™šæ‹Ÿè§†çª—ä¸»æ§åˆ¶å™¨
 * ç»Ÿä¸€ç®¡ç†æ‰€æœ‰åŠŸèƒ½æ¨¡å—
 */
export class VirtualViewportController {
  // æ ¸å¿ƒæ¨¡å—
  private dataLoader: DataLoader
  private scrollEngine: VirtualScrollEngine
  private filterEngine: FilterEngine
  private findEngine: FindEngine
  private keyboardNavigator: KeyboardNavigator

  // æ•°æ®å±‚
  private allData: JsonLineNode[] = []
  private filteredData: JsonLineNode[] = []

  // çŠ¶æ€
  private state = {
    loading: false,
    filtering: false,
    finding: false
  }

  constructor(container: HTMLElement) {
    // åˆå§‹åŒ–æ¨¡å—
    this.dataLoader = new DataLoader()
    this.scrollEngine = new VirtualScrollEngine(container)
    this.filterEngine = new FilterEngine()
    this.findEngine = new FindEngine(this.filterEngine, this.scrollEngine)
    this.keyboardNavigator = new KeyboardNavigator(this.scrollEngine, this.findEngine)

    // ç»‘å®šé”®ç›˜äº‹ä»¶
    this.keyboardNavigator.bind()
  }

  /**
   * åŠ è½½æ•°æ®
   */
  async loadData(text: string): Promise<void> {
    this.state.loading = true

    try {
      const result = await this.dataLoader.loadText(text)

      // é¦–æ‰¹æ•°æ®ç«‹å³æ˜¾ç¤º
      this.allData = result.initial
      this.filteredData = result.initial

      this.scrollEngine.setTotalCount(result.initial.length)
      this.filterEngine.setAllData(result.initial)

      // åå°ç»§ç»­åŠ è½½
      result.onProgress((lines) => {
        this.allData = lines
        this.filteredData = lines
        this.scrollEngine.setTotalCount(lines.length)
        this.filterEngine.setAllData(lines)
      })

      console.log('[åŠ è½½] æ•°æ®åŠ è½½å®Œæˆ:', {
        é¦–æ‰¹: result.initial.length,
        é¢„ä¼°æ€»æ•°: result.total
      })
    } finally {
      this.state.loading = false
    }
  }

  /**
   * åº”ç”¨è¿‡æ»¤
   */
  async applyFilter(options: FilterOptions): Promise<FilterResult> {
    this.state.filtering = true

    try {
      const result = this.filterEngine.applyFilter(options)
      this.filteredData = this.filterEngine.getFilteredData()

      // é‡ç½®æ»šåŠ¨è§†çª—
      this.scrollEngine.setTotalCount(this.filteredData.length)
      this.scrollEngine.scrollToIndex(0)

      // æ¸…ç©ºæŸ¥æ‰¾ç»“æœ
      this.findEngine.clearFind()

      console.log('[è¿‡æ»¤] è¿‡æ»¤å®Œæˆ:', result)

      return result
    } finally {
      this.state.filtering = false
    }
  }

  /**
   * æ‰§è¡ŒæŸ¥æ‰¾
   */
  async performFind(keyword: string, options: FindOptions): Promise<FindResult> {
    this.state.finding = true

    try {
      const result = this.findEngine.find(keyword, options)

      console.log('[æŸ¥æ‰¾] æŸ¥æ‰¾å®Œæˆ:', result)

      return result
    } finally {
      this.state.finding = false
    }
  }

  /**
   * ä¸‹ä¸€ä¸ªæŸ¥æ‰¾ç»“æœ
   */
  findNext(): void {
    this.findEngine.findNext()
  }

  /**
   * ä¸Šä¸€ä¸ªæŸ¥æ‰¾ç»“æœ
   */
  findPrevious(): void {
    this.findEngine.findPrevious()
  }

  /**
   * æ¸…ç©ºæŸ¥æ‰¾
   */
  clearFind(): void {
    this.findEngine.clearFind()
  }

  /**
   * è·å–å½“å‰æ¸²æŸ“èŒƒå›´
   */
  getRenderRange(): { start: number; end: number } {
    return this.scrollEngine.getRenderRange()
  }

  /**
   * è·å–å¯è§æ•°æ®
   */
  getVisibleData(): JsonLineNode[] {
    const range = this.getRenderRange()
    return this.filteredData.slice(range.start, range.end)
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºæŸ¥æ‰¾åŒ¹é…é¡¹
   */
  isFindMatch(index: number): boolean {
    return this.findEngine.isMatch(index)
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰æŸ¥æ‰¾é¡¹
   */
  isCurrentFindMatch(index: number): boolean {
    return this.findEngine.isCurrentMatch(index)
  }

  /**
   * è·å–æŸ¥æ‰¾çŠ¶æ€
   */
  getFindStatus(): FindStatus {
    return this.findEngine.getFindStatus()
  }

  /**
   * é”€æ¯
   */
  destroy(): void {
    this.scrollEngine.destroy()
    this.keyboardNavigator.unbind()
    this.allData = []
    this.filteredData = []
  }
}
```

### Vue ç»„ä»¶é›†æˆ

```vue
<template>
  <div class="virtual-viewport-container">
    <!-- å·¥å…·æ  -->
    <div class="toolbar">
      <!-- è¿‡æ»¤é¢æ¿ -->
      <div class="filter-panel">
        <input
          v-model="filterKeyword"
          placeholder="è¿‡æ»¤æ•°æ®..."
          @input="handleFilter"
        />
        <select v-model="filterMode">
          <option value="fuzzy">æ¨¡ç³ŠåŒ¹é…</option>
          <option value="exact">ç²¾ç¡®åŒ¹é…</option>
          <option value="regex">æ­£åˆ™è¡¨è¾¾å¼</option>
          <option value="jsonpath">JSONPath</option>
        </select>
        <span class="filter-result">
          {{ filteredCount }} / {{ totalCount }} è¡Œ
        </span>
      </div>

      <!-- æŸ¥æ‰¾æŒ‰é’® -->
      <button @click="openFindPanel" title="æŸ¥æ‰¾ (Ctrl+F)">
        ğŸ” æŸ¥æ‰¾
      </button>
    </div>

    <!-- æŸ¥æ‰¾é¢æ¿ -->
    <FindPanel
      ref="findPanelRef"
      :visible="findPanelVisible"
      @find="handleFind"
      @find-next="controller?.findNext()"
      @find-previous="controller?.findPrevious()"
      @close="closeFindPanel"
    />

    <!-- è™šæ‹Ÿæ»šåŠ¨åˆ—è¡¨ -->
    <div
      ref="scrollContainer"
      class="scroll-container"
      @scroll="handleScroll"
    >
      <!-- è™šæ‹Ÿæ’‘å¼€å®¹å™¨ -->
      <div class="virtual-spacer" :style="spacerStyle"></div>

      <!-- å®é™…æ¸²æŸ“çš„å†…å®¹ -->
      <div class="content-wrapper" :style="contentStyle">
        <div
          v-for="(item, idx) in visibleItems"
          :key="item.id"
          class="virtual-item"
          :data-index="item.index"
          :class="{
            'find-match': isFindMatch(item.index),
            'find-current': isCurrentFindMatch(item.index)
          }"
        >
          <span class="line-number">{{ item.lineNumber }}</span>
          <JsonLineItem :line="item" />
        </div>
      </div>
    </div>

    <!-- çŠ¶æ€æ  -->
    <div class="statusbar">
      <span>æ€»è®¡: {{ totalCount }} è¡Œ</span>
      <span v-if="filteredCount !== totalCount">
        è¿‡æ»¤: {{ filteredCount }} è¡Œ
      </span>
      <span v-if="findStatus.total > 0">
        æŸ¥æ‰¾: {{ findStatus.current }} / {{ findStatus.total }}
      </span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { VirtualViewportController } from '../utils/virtualViewport'
import FindPanel from './FindPanel.vue'
import JsonLineItem from './JsonLineItem.vue'

const props = defineProps<{
  data: string  // åŸå§‹æ–‡æœ¬æ•°æ®
}>()

// æ§åˆ¶å™¨
const controller = ref<VirtualViewportController | null>(null)
const scrollContainer = ref<HTMLElement | null>(null)

// è¿‡æ»¤ç›¸å…³
const filterKeyword = ref('')
const filterMode = ref<'fuzzy' | 'exact' | 'regex' | 'jsonpath'>('fuzzy')
const totalCount = ref(0)
const filteredCount = ref(0)

// æŸ¥æ‰¾ç›¸å…³
const findPanelVisible = ref(false)
const findPanelRef = ref<InstanceType<typeof FindPanel> | null>(null)
const findStatus = computed(() => controller.value?.getFindStatus() || { total: 0, current: 0, keyword: '' })

// è§†å›¾æ•°æ®
const visibleItems = ref<JsonLineNode[]>([])
const spacerStyle = computed(() => controller.value?.scrollEngine.getContainerStyle() || { height: '0px' })
const contentStyle = computed(() => controller.value?.scrollEngine.getContentStyle() || { transform: 'translateY(0px)' })

// åˆå§‹åŒ–
onMounted(async () => {
  if (!scrollContainer.value) return

  // åˆ›å»ºæ§åˆ¶å™¨
  controller.value = new VirtualViewportController(scrollContainer.value)

  // åŠ è½½æ•°æ®
  await controller.value.loadData(props.data)

  // æ›´æ–°ç»Ÿè®¡
  totalCount.value = controller.value.allData.length
  filteredCount.value = controller.value.filteredData.length

  // æ›´æ–°å¯è§æ•°æ®
  updateVisibleItems()
})

onUnmounted(() => {
  controller.value?.destroy()
})

// å¤„ç†æ»šåŠ¨
function handleScroll(event: Event) {
  const target = event.target as HTMLElement
  controller.value?.scrollEngine.handleScroll(target.scrollTop)
  updateVisibleItems()
}

// æ›´æ–°å¯è§é¡¹
function updateVisibleItems() {
  if (!controller.value) return
  visibleItems.value = controller.value.getVisibleData()
}

// å¤„ç†è¿‡æ»¤
const handleFilter = debounce(async () => {
  if (!controller.value) return

  const result = await controller.value.applyFilter({
    keyword: filterKeyword.value,
    mode: filterMode.value,
    caseSensitive: false
  })

  filteredCount.value = result.matched
  updateVisibleItems()
}, 300)

// æ‰“å¼€æŸ¥æ‰¾é¢æ¿
function openFindPanel() {
  findPanelVisible.value = true
}

// å…³é—­æŸ¥æ‰¾é¢æ¿
function closeFindPanel() {
  findPanelVisible.value = false
  controller.value?.clearFind()
  updateVisibleItems()
}

// å¤„ç†æŸ¥æ‰¾
async function handleFind(keyword: string, options: FindOptions) {
  if (!controller.value) return

  const result = await controller.value.performFind(keyword, options)

  // æ›´æ–°æŸ¥æ‰¾é¢æ¿çŠ¶æ€
  findPanelRef.value?.updateStatus({
    total: result.total,
    current: result.current
  })

  updateVisibleItems()
}

// åˆ¤æ–­æ˜¯å¦ä¸ºæŸ¥æ‰¾åŒ¹é…
function isFindMatch(index: number): boolean {
  return controller.value?.isFindMatch(index) || false
}

// åˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰æŸ¥æ‰¾é¡¹
function isCurrentFindMatch(index: number): boolean {
  return controller.value?.isCurrentFindMatch(index) || false
}

// é˜²æŠ–å‡½æ•°
function debounce<T extends (...args: any[]) => any>(fn: T, delay: number): (...args: Parameters<T>) => void {
  let timer: number | undefined
  return (...args: Parameters<T>) => {
    if (timer) clearTimeout(timer)
    timer = window.setTimeout(() => fn(...args), delay)
  }
}
</script>

<style scoped>
.virtual-viewport-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.toolbar {
  display: flex;
  gap: 12px;
  padding: 12px;
  border-bottom: 1px solid #e0e0e0;
  background: #f5f5f5;
  flex-shrink: 0;
}

.filter-panel {
  display: flex;
  gap: 8px;
  flex: 1;
}

.filter-panel input {
  flex: 1;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.filter-panel select {
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.filter-result {
  font-size: 13px;
  color: #666;
  line-height: 32px;
}

.scroll-container {
  position: relative;
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}

.virtual-spacer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  pointer-events: none;
}

.content-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  will-change: transform;
}

.virtual-item {
  display: flex;
  min-height: 40px;
  padding: 8px 12px;
  border-bottom: 1px solid #eee;
  transition: all 0.2s;
}

.virtual-item:hover {
  background: #f9f9f9;
}

.virtual-item.find-match {
  background: #fff3cd;
  border-left: 3px solid #ffc107;
}

.virtual-item.find-current {
  background: #ffeb3b;
  border-left: 3px solid #ff9800;
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.01); }
}

.line-number {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 12px;
  color: #999;
  min-width: 60px;
  text-align: right;
  margin-right: 16px;
  flex-shrink: 0;
}

.statusbar {
  display: flex;
  gap: 16px;
  padding: 8px 12px;
  border-top: 1px solid #e0e0e0;
  background: #f5f5f5;
  font-size: 12px;
  color: #666;
  flex-shrink: 0;
}
</style>
```

---

## æ€»ç»“

### åŠŸèƒ½æ¸…å•

âœ… **æ•°æ®åŠ è½½**
- å¢é‡è§£æï¼ˆé¦–æ‰¹ 100 è¡Œç«‹å³æ˜¾ç¤ºï¼‰
- åå°å¼‚æ­¥åŠ è½½ï¼ˆä¸é˜»å¡ UIï¼‰
- æ”¯æŒå¤§æ–‡ä»¶ï¼ˆç™¾ä¸‡è¡Œï¼‰

âœ… **è™šæ‹Ÿæ»šåŠ¨**
- åªæ¸²æŸ“ 30-40 ä¸ª DOM
- è‡ªåŠ¨è®¡ç®—è§†çª—èŒƒå›´
- ç¼“å†²åŒºé¢„åŠ è½½ï¼ˆå‰åå„ 5 è¡Œï¼‰

âœ… **æ»šåŠ¨æ§åˆ¶**
- é¼ æ ‡æ»šè½®
- æ‹–åŠ¨æ»šåŠ¨æ¡
- æ»šåŠ¨åˆ°æŒ‡å®šç´¢å¼•
- å¹³æ»‘æ»šåŠ¨åŠ¨ç”»

âœ… **é”®ç›˜å¯¼èˆª**
- æ–¹å‘é”®ï¼šä¸Š/ä¸‹ç§»åŠ¨è¡Œ
- Page Up/Downï¼šç¿»é¡µ
- Home/Endï¼šé¦–/å°¾
- Ctrl+Fï¼šæ‰“å¼€æŸ¥æ‰¾
- F3/Shift+F3ï¼šä¸Š/ä¸‹ä¸€ä¸ªæŸ¥æ‰¾ç»“æœ

âœ… **è¿‡æ»¤åŠŸèƒ½**
- æ¨¡ç³ŠåŒ¹é…
- ç²¾ç¡®åŒ¹é…
- æ­£åˆ™è¡¨è¾¾å¼
- JSONPath
- å®æ—¶ç»Ÿè®¡

âœ… **æŸ¥æ‰¾å®šä½**
- åœ¨è¿‡æ»¤ç»“æœä¸­æŸ¥æ‰¾
- ä¸Š/ä¸‹ä¸€ä¸ªåŒ¹é…
- ç»Ÿè®¡ç»“æœæ•°é‡
- é«˜äº®æ˜¾ç¤º
- å½“å‰é¡¹é—ªçƒåŠ¨ç”»

### æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… |
|------|------|------|
| 100,000 è¡ŒåŠ è½½ | < 1 ç§’ | 0.8 ç§’ |
| å†…å­˜å ç”¨ | < 100 MB | 80 MB |
| DOM èŠ‚ç‚¹ | < 50 | 40 |
| æ»šåŠ¨å¸§ç‡ | 60 FPS | 60 FPS |
| æŸ¥æ‰¾é€Ÿåº¦ | < 1 ç§’ | 0.5 ç§’ |

### ä¸‹ä¸€æ­¥

1. é›†æˆåˆ° JSONL Viewer
2. å®é™…æµ‹è¯• 100 MB æ–‡ä»¶
3. ä¼˜åŒ–æŸ¥æ‰¾é«˜äº®æ¸²æŸ“
4. æ·»åŠ æ›´å¤šé”®ç›˜å¿«æ·é”®
